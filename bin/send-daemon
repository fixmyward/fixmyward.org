#!/usr/bin/env perl
#
# send-daemon
# FixMyStreet daemon for sending reports and updates.

use strict;
use warnings;
use v5.14;
$|++;

BEGIN {
    use File::Basename qw(dirname);
    use File::Spec;
    my $d = dirname(File::Spec->rel2abs($0));
    require "$d/../setenv.pl";
}

use Getopt::Long::Descriptive;
use Parallel::ForkManager;
use CronFns;
use FixMyStreet;
use FixMyStreet::DB;
use FixMyStreet::Script::Reports;
use FixMyStreet::Queue::Item::Report;
use Open311::PostServiceRequestUpdates;
use Try::Tiny;

my ($opts, $usage) = describe_options(
    '%c %o',
    ['verbose|v+', 'more verbose output'],
    ['nomail', 'do not send any email, print instead'],
    ['debug', 'always try and send reports (no back-off skipping)'],
    ['help|h', "print usage message and exit" ],
    [],
    ['Send a USR1 signal to the parent to cycle through verbose levels.'],
);
$usage->die if $opts->help;
my $verbose = $opts->verbose || 0;

my $site = CronFns::site(FixMyStreet->config('BASE_URL'));
my $states = [ FixMyStreet::DB::Result::Problem::open_states() ];
$states = [ 'submitted', 'confirmed', 'in progress', 'feedback pending', 'external', 'wish' ] if $site eq 'zurich';

my $db = FixMyStreet::DB->schema->storage;

my %children;

my $exit = 0;
$SIG{TERM} = $SIG{INT} = sub { $exit = 1; };

my $changeverboselevel = 0;
$SIG{USR1} = sub {
    kill 'USR1', keys %children;
    ++$changeverboselevel;
};

my $procs = FixMyStreet->config('QUEUE_DAEMON_PROCESSES') || 4;
my $pm = Parallel::ForkManager->new($procs);

$pm->run_on_start(sub {
    my $pid = shift;
    $children{$pid} = time();
});
$pm->run_on_finish(sub {
    my ($pid, $child_exit_code) = @_;
    warn ('P: ', $pid, '. CXC: ', $child_exit_code);

    if ($child_exit_code) {
        # error, reap child processes 
        kill 'TERM', keys %children;
    }
    elsif ($children{$pid} > time() - 10) {
        # It didn't live very long, let's wait a bit
        sleep(5);
    }
    delete $children{$pid};
});

# The parent loop
while (!$exit) {

    while (keys %children < $procs) {
        $pm->start and next;
        warn 'just started ' . $$;
        srand;
        $SIG{USR1} = sub { ++$changeverboselevel; };

        # respond to any parent call to exit
        $SIG{TERM} = sub {
            warn "$$ exiting now due to parent reap";
            $pm->finish;
        };

        while (!$exit) {
            $0 = "fmsd (running queue)";
            my %row_tracking;
            try {
                print_log('info', 'looking for reports');
                $db->txn_do(\&look_for_report, \%row_tracking);
                print_log('info', 'looking for updates');
                $db->txn_do(\&look_for_update);
                $0 = "fmsd";
            } catch {
                warn "Error while attempting to send report or check for updates.\n$_";
                # trim HTML error
                $row_tracking{error} =~ s/.*("<.*>").*/$1/;
                if (exists $row_tracking{row}) {
                    try {
                        $row_tracking{row}->update_send_failed($row_tracking{error} || 'unknown error');
                    } catch {
                        print_log('info', 'Could not record failure info after failing to send report.')
                    };
                }
                $pm->finish(2); # error code
            };
            sleep(5 + rand(10));
        }
        say 'finishing child proc';
        $pm->finish;
    }
    say 'back in parent loop';
    if (!keys %children) { # Very high load, something wrong
        say 'no keys in %children';
        sleep(10);
        next;
    }
    say 'waiting for available procs...';
    $pm->wait_for_available_procs;
}

sub look_for_report {
    my $row_hash = shift;   
    my $params = FixMyStreet::Script::Reports::construct_query($opts->debug);
    my $unsent = FixMyStreet::DB->resultset('Problem')->search($params, {
        for => \'UPDATE SKIP LOCKED',
        rows => 1,
    } )->single or return;
    $row_hash->{row} = $unsent;
    print_log('debug', "Trying to send report " . $unsent->id);
    try {
        my $item = FixMyStreet::Queue::Item::Report->new(
            report => $unsent,
            verbose => $verbose,
            nomail => $opts->nomail,
        );
        $item->process;
    } catch {
        print_log('info', "Failed to send report ", $unsent->id, "\n$_");
        $row_hash->{error} = $_;
        die $_; # rethrow to kill off sibling procs
    };
}

sub look_for_update {
    my $updates = Open311::PostServiceRequestUpdates->new(
        verbose => $verbose,
    );

    my $bodies = $updates->fetch_bodies;
    my $params = $updates->construct_query($opts->debug);
    my $comment = FixMyStreet::DB->resultset('Comment')
        ->to_body([ keys %$bodies ])
        ->search($params, { for => \'UPDATE SKIP LOCKED', rows => 1 })
        ->single or return;

    print_log('debug', "Trying to send update " . $comment->id);

    my ($body) = grep { $bodies->{$_} } @{$comment->problem->bodies_str_ids};
    $body = $bodies->{$body};

    $updates->process_update($body, $comment);
}

sub print_log {
    my $prio = shift;

    if ($changeverboselevel) {
        $verbose = ($verbose + $changeverboselevel) % 3;
        STDERR->print("fmsd: info: verbose level now $verbose\n");
        $changeverboselevel = 0;
    }

    if ($verbose < 2) {
        return if ($prio eq 'noise');
        return if ($verbose < 1 && $prio eq 'debug');
        return if ($verbose < 0 && $prio eq 'info');
    }
    STDERR->print("[fmsd] [$prio] ", join("", @_), "\n");
}
